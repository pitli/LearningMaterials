### 微服务架构概述



## 单体应用架构存在的问题

一个归档包（例如war包）包含所有功能的应用程序，通常称为单体应用。而架构单体应用的方法论，就是单体应用架构。

单体应用比较容易部署、测试，在项目初期单体应用可很好运行。然而，随着需求的不断增加，开发团队人越来越多，代码库飞速膨胀。慢慢地，单体应用越来越臃肿。可维护性、灵活性逐渐降低，维护成本增加。下面列举单体应用的一些问题：

- 复杂性高：项目包含模块多、模块边界模糊、依赖关系不清晰、代码质量参差不齐。修改代码和添加一个简单的功能，或修改一个Bug都会带来隐含的缺陷。
- 技术债务：“不坏不修”，在软件开发中非常常见，在单体应用中这种思想更甚。已使用的系统设计或代码难以被修改，因为应用程序中其他模块可能会以意料之外的方式使用它。
- 部署频率低：在单体应用中，每次功能的变更或缺陷的修复会导致需重新部署整个应用。全量部署的方式耗时长、影响范围大、风险高，使得单体应用上线部署的频率较低。部署频率低又导致两次发布之间会有大量功能得变更和缺陷修复，出错概率比较高。
- 可靠性差：某个应用Bug，例如死循环、OOM等，可能会导致整个应用的崩溃。
- 扩展能力受限：单体应用只能作为一个整体进行扩展，无法根据业务模块的需求进行伸缩。例如有模块时计算密集型，需要强劲CPU；有的是IO密集型，需更大内存。由于这些模块在一起，不得不在硬件选择做出妥协。
- 阻碍技术创新：单体应用往往使用统一的技术平台或方案解决所有问题，团队中所有人都必须使用相同开发语言和框架，想引入新框架或新技术平台会非常困难。

## 什么是微服务

目前来看，微服务本身并没有一个严格的定义，每个人对微服务的理解都不同。Martin Fowler在他博客中描述的微服务应具备以下特性：

- 每个微服务可独立运行在自己的进程里
- 一系列独立运行的微服务共同构建起整个系统
- 每个服务为独立的业务开发，一个微服务只关注某个特定的功能，例如订单管理、用户管理等
- 微服务之间通过一些轻量的通信机制进行通信，例如通过RESTful API进行调用
- 可以使用不同的语言与数据存储技术
- 全自动的部署机制

> **备注：** Martin Fowler《微服务》博客原文：[Microservices](https://www.martinfowler.com/articles/microservices.html)，译文：[微服务](http://blog.cuicc.com/blog/2015/07/22/microservices/)

## 微服务架构的优点

微服务架构有如下优点：

- 易于开发和维护：一个微服务只关注一个特定的业务功能，所有业务清晰、代码量较少。开发和维护单个微服务相对简单
- 单个微服务启动较快：单个微服务代码量较少，所以启动会比较快
- 局部修改容易部署：一般来说，对某个微服务进行修改，只需重新部署这个服务即可
- 技术栈不受限：在微服务架构中，可以结合项目业务及团队的特点，合理的选择技术栈。例如某些服务可使用MySQL；某些服务有图形计算需求，可使用Neo4j
- 按需伸缩：可根据需求，实现细粒度的扩展。例如某个服务遇到瓶颈，可结合服务特点，增加内存、升级CPU或是增加节点

## 微服务架构面临的挑战

- 运维要求较高：更多的服务意味更多的运维投入
- 分布式固有的复杂性：使用微服务构建的时分布式系统。对于分布式系统，系统容错、网络延迟、分布式事务等都会带来巨大挑战
- 接口调整成本高：微服务之间通过接口通信。如果修改某一个服务的API，可能所有使用了该接口的微服务都需要做出调整
- 重复劳动：很多服务可能都会使用到相同的功能，而这个功能没有达到分解为一个微服务的程度，这时可能各个服务都会开发这一功能，从而导致代码重复。尽管可使用共享库解决这个问题，但共享库在多语言环境下不一定行得通

## 微服务设计原则

和数据库设计中的N范式一样，微服务也有一定的的设计原则，这些原则指导我们更加合理地架构微服务。

- 单一职责原则：单一职责原则指一个单元（类、方法或服务）只应关注整个系统功能中单独、有界限的一部分。单一职责原则可帮助我们更优雅地开发、更敏捷地交付。单一职责原则时SOLID原则之一
- 服务自治原则：服务自治指每个微服务应具备独立的业务能力、依赖与运行环境。在微服务架构中，服务时独立的业务单元，应与其他服务高度解耦。每个微服务从开发、测试、构建、部署，都应可以独立运行，而不应依赖其他的服务
- 轻量级通信机制：微服务之间应该通过轻量级的通信机制进行交互。例如我们所熟系的REST协议，就是一个典型的“轻量级通信机制”
- 微服务粒度：微服务的粒度是难点，也是常常争论的焦点。应当使用合理的粒度划分微服务，而不是一味地把微服务做小。代码量的多少不能作为微服务划分的依据，因为不同的微服务本身的业务复杂性不同，代码量也不同

## 服务提供者与服务消费者

## 编写服务提供者

为便于测试，使用Spring Data JPA作为持久层框架，使用H2作为数据库

创建一个maven项目，ArtifactId是microservice-provider-user，pom.xml内容如下：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>com.itmuch.cloud</groupId>
	<artifactId>microservice-simple-provider-user</artifactId>
	<version>1.0.0-SNAPSHOT</version>
	<packaging>jar</packaging>
	
    <!--引入Spring Boot的依赖-->
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>1.4.3.RELEASE</version>
	</parent>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<java.version>1.8</java.version>
	</properties>

	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		<dependency>
			<groupId>com.h2database</groupId>
			<artifactId>h2</artifactId>
		</dependency>
	</dependencies>

    <!--引入Spring Cloud的依赖-->
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>Camden.SR4</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

    <!--添加Spring Boot的maven插件-->
	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>
</project>
```

准备好建表语句，在项目的resources下建立schema.sql，添加如下内容：

```sql
drop table user if exists;
create table user (id bigint generated by default as identity, username varchar(40), name varchar(20), age int(3), balance decimal(10,2), primary key(id));
```

准备数据，在项目的resources下建立data.sql，添加如下内容：

```sql
insert into user (id, username, name, age, balance) values (1, 'account1', '张三', 20, 100.00);
insert into user (id, username, name, age, balance) values (2, 'account2', '李四', 28, 180.00);
insert into user (id, username, name, age, balance) values (3, 'account3', '王五', 32, 280.00);
```

创建用户实体类：

```java
package com.itmuch.cloud.simpleprovideruser.entity;

import java.math.BigDecimal;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class User {

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private Long id;
	@Column
	private String username;
	@Column
	private String name;
	@Column
	private Integer age;
	@Column
	private BigDecimal balance;
    //get and set
}

```

创建Dao：

```java
import org.springframework.data.jpa.repository.JpaRepository;

import com.itmuch.cloud.simpleprovideruser.entity.User;

public interface UserRepository extends JpaRepository<User, Long>{

}
```

创建Controller：

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import com.itmuch.cloud.simpleprovideruser.dao.UserRepository;
import com.itmuch.cloud.simpleprovideruser.entity.User;

@RestController
public class UserController {
	
	@Autowired
	private UserRepository userRepository;
	
	@GetMapping("/{id}")
	public User findById(@PathVariable Long id) {
		User findOne = this.userRepository.findOne(id);
		return findOne;
	}

}
```

编写启动类：

```java
@SpringBootApplication
public class ProvideruserApplication {
	
	public static void main(String[] args) {
		SpringApplication.run(ProvideruserApplication.class, args);
	}

}
```

编写配置文件application.yml：

```yml
server:
  port: 8000
spring:
  jpa:
    generate-ddl: false
    show-sql: true
    hibernate:
      ddl-auto: none
  datasource:
    platform: h2
    schema: classpath:schema.sql
    data: classpath:data.sql
logging:
  level:
    root: INFO
    org.hibernate: INFO
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
    org.hibernate.type.descriptor.sql.BasicExtractor: TRACE
```

启动项目访问 http://localhost:8000/1查看数据是否存在。

## 编写消费者

创建一个maven项目，ArtifactId是microservice-consumer-movie，该服务比较简单，使用RestTemplate调用用户微服务的API，从而查询指定id的用户信息，pom.xml需添加的依赖于提供者一致。

创建用户实体类，该类时POJO：

```java
public class User {

	private Long id;
	private String username;
	private String name;
	private Integer age;
	private BigDecimal balance;
    //get and set
}
```

创建启动类：

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
public class ConsumerMovieApplication {
	
	@Bean
	public RestTemplate restTemplate() {
		return new RestTemplate();
	}
	
	public static void main(String[] args) {
		SpringApplication.run(ConsumerMovieApplication.class, args);
	}

}
```

创建Controller，使用RestTemplate请求用户微服务的API：

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import com.itmuch.cloud.simpleconsumermovie.pojo.User;

@RestController
public class MovieController {

	@Autowired
	private RestTemplate restTemplate;
	
	@GetMapping("/user/{id}")
	public User findById(@PathVariable Long id) {
		return this.restTemplate.getForObject("http://localhost:8000/"+id, User.class);
	}
}
```

编写配置文件application.yml：

```yml
server:
 port: 8010
```

启动项目，在启动服务提供者，访问，http://localhost:8010/user/1查询数据是否返回。